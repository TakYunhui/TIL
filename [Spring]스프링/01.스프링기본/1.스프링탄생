# 스프링 탄생
1. EJB(Enterprise Java Beans) : 자바 진영 표준 기술 
- 컨테이너 기술, 트랜잭션 설정, 분산 기술(서버와 계층), 엔티티빈(ORM기술) 지원
- 어렵고, 복잡하고, 느리다! 
2. POJO(Plan Old Java Object) : 오래된 방식의 간단한 자바 오브젝트 사용
- Entity Bean은 기술 수준이 빈약하다.
- Hibernate, Spring 오픈소스의 개발 
    - 단순하면서 좋은 기술
3. JPA(구현체 80% Hibernate)
- 표준 정제: 실용성과 안정성 
- EJB 없이 고품질의 확장 가능한 애플리케이셔 개발 

---
# 스프링 역사
## 릴리즈
스프링 1.0 : XML
스프링 2.0 : XML 편의 기능 지원
스프링 3.0 : 자바 코드로 설정
스프링 4.0 : 자바8
스프링부트 1.0 출시

# 스프링?
- 여러 기술들의 모음
[필수]
1. 스프링 프레임워크
2. 스프링부트
[선택]
1. 스프링 데이터 - 스프링 데이터 JPA 가장 많이 사용
2. 스프링 세션
3. 스프링 시큐리티
4. 스프링 Rest Docs : API 문서 + 테스트를 묶어서 문서화 도와줌
5. 스프링 배치 
6. 스프링 클라우드 

---
[스프링 사용]
1. 스프링 DI 컨테이너 기술
2. 스프링 프레임워크
3. 스프링 생태계 
---
## 핵심 개념 
- Java언어 기반의 프레임워크로 객체지향프로그램 개발을 지원
---
# 좋은 객체 지향 프로그래밍
## 객체 지향 프로그래밍
- 여러 개의 독립 단위, "객체"들의 모임으로 파악
- 객체는 메세지를 주고 받고 데이터를 처리할 수 있다
- 유용하고 변경이 용이하다
    - ex) 레고 부품을 갈아끼우듯 컴포넌트를 바꿔끼워넣을 수 있다

## 다형성
- 세상을 역할(인터페이스)과 구현(인터페이스를 구현한 클래스, 구현 객체)으로 구분
    - ex1) 
    - 역할: 자동차
    - 구현: K3, 아반떼, 벤츠

    - ex2)
    - 역할: 로미오 역
    - 구현: 장동건, 원빈

- 구현보다 인터페이스를 먼저 설계한다 
- 객체의 협력 관계를 먼저 생각!
    - 혼자 있는 객체는 없다
    - 클라이언트: 요청
    - 서버: 응답
    - 수 많은 객체 클라이언트와 서버는 서로 협력 관계를 가진다.

### 자바 언어의 다형성
- 오버라이딩으로 동작
- 인터페이스로 구현된 객체를 실행 시점에 유연하게 변경 가능
- 의존한다?
    - 내가 쟤를 알고 있다! 
### 다형성의 본질
> 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

### 역할과 구현을 분리
- 인터페이스를 안정적으로 잘 설계하는 것이 중요

---
## 스프링과 객체 지향
- 스프링은 다형성을 극대화해서 이용할 수 있도록 도와준다
- 제어의 역전(IoC), 의존관계 주입(DI)이 역할과 구현을 편리하게 다루도록 지원

### SOLID 좋은 객체 지향 설계의 5가지 원칙
1. SRP (단일 책임 원칙)
- 한 클래스는 하나의 책임만 가져야 한다.
- 중요한 기준은 "변경" 
    - 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
    - ex) UI 변경, 객체의 생성과 사용을 분리
2. OCP (개방-폐쇄 원칙)
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
- 다형성 활용
- But...
    - MemberService 구현 객체
    - MemberRepository의 MemoryMemberRepository -> JdbcMemberReposiroty
    - 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다
    - 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다! 
    - 객체를 생성하고, 연관관계를 맺는 별도의 조립, 설정자가 필요
    - 이 별도의 뭔가를 스프링이 해줌! (소위 스프링 컨테이너의 역할)
    - 이때, IoC, DI가 필요하게 된다
3. LSP 리스코프 치환 원칙
- 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바뀔 수 있어야 한다.
- 하위 클래스는 인터페이스 규약을 다 지켜야 한다!
    - ex) 엑셀을 밟으면 앞으로 가야한다 
    - 뒤로 가게 구현하면 리스코프 치환 원칙을 위반한 것
4. ISP 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 인터페이스를 분리하여 복잡성 해소
5. DIP 의존관계 역전 원칙
- 프래그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다
- 클라이언트가 역할(인터페이스)에 의존해야지 구현에 의존하면 안된다
- ex) MemberService MemoryMemberRepository
    - MemberService 클라이언트가 구현 클래스를 직접 선택 
    - DIP 위반! 
=> 다형성만으로 OCP, DIP를 지킬 수 없다.
=> 어떻게 해결하지?

### 스프링과 객체 지향 설계
○ 스프링은 OCP, DIP를 가능하게 지원한다
- DI: 의존관계, 의존성 주입
- DI 컨테이너 제공
- 클라이언트 코드 변경 없이 기능 확장

### 실무에서는?
1. 인터페이스를 도입하면 추상화라는 비용이 발생
- 개발자 코드를 한번 더 열어봐야 한다 
    - 인터페이스만 보면 구현 클래스를 확인해야 한다
2. 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고, 향후 리팩터링해서 인터페이스를 도입하는 것도 방법이다


