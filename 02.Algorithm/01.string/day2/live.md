# 문자열 알고리즘 -> 검색
## Brute Force Algorithm
- 본문 문자열을 처음부터 끝까지 차례대로 순회하며 패턴 내 문자들을 일일이 비교
- pattern이 text 안에 있는지 시작 위치부터 확인
- 일치하면 다음 자리로 넘어가다가, 불일치가 발생하면
- t는 시작점 다음 자리(i+1), p는 원점으로 간다 
- O(MN)

```python
p = "is" # 찾을 패턴
t = "This is a book~!" # 전체 텍스트
M = len(p)
N = len(t)

def BruteForce(p, t):
  i = 0 # t의 인덱스
  j = 0 # p의 인덱스
  while j < M and i < N: # 둘다 텍스트 내부(자기 길이)에 있어야 함 
    if t[i] != p[j]: # 불일치 

      i = i - j      # 다음 시작점: 내가 갔던 만큼 빼주기 
      j = -1         # 다음 시작점: 맨 처음으로 되돌리기 
    
    # if 조건이 맞지 않으면(일치)
    # 다음 동작에 무조건 증가 -> 다음 칸 보러가기 
    i = i + 1 
    j = j + 1 
  if j == M : 
    return i - M # 검색 성공
  else:
    return - 1   # 검색 실패
```

## KMP 알고리즘
- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
- 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시간을 최소화
- 패턴 안에 패ㅓㄴ=
- O(M+N)

```python
i = 0 # 비교 텍스트 위치
j = 0 # 비교 패턴 위치
while i < N and j < M: # 텍스트 범위 내여야 한다 
    if j == -1 or t[i] == p[j]: # 첫글자가 불일치했거나 일치하면
      i += 1
      j += 1
    else:       # 불일치
      j = lps[j]
    if j == M:  # 패턴을 찾을 경우
    print(i-M, end = ' ') # 패턴의 인덱스 출력
    j = lps[j]
print()
return
```

## 보이어-무어 알고리즘
- 오른쪽에서 왼쪽으로 비교 : 뒤에서부터 찾기 