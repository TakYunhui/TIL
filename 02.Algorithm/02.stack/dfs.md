# DFS(깊이 우선 탐색)
- 비선형인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요
- 깊이 우선 탐색(DFS) > Stack 활용
- 너비 우선 탐색(BFS) > Queue 활용

## DFS
- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색
- 더이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길에서 다른 길로 탐색을 이어가는 방법
- 스택은 지나온 길을 저장하는 도구일 뿐!! 꼭 스택이어야 할 필요는 없다 (재귀를 이용하기도 하고...)

- 1. 시작 정점 v를 결정하여 방문
- 2. 정점 v에 인접한 정점 중에서 
   - 1. 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w 방문,
        그리고 w를 v로 하여 다시 큰-2과정을 반복
   - 2. 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은
        가장 마지막 방문 정점을 v로 하여 다시 큰-2과정을 반복
- 3. 스택이 공백이 될 때까지 2 과정을 반복
- 되돌아갈 정보가 필요하므로 v를 push해 스택에 넣어둔다!

```
# 슈도코드 
visited[], stack[] # 초기화
DFS(v)
   시작점 v 방문;
   visited[v] <-true;
   while {
    if (v의 인접 정점 중 방문 안 한 정점 w가 있으면)
        push(v);
        v <- w; (w에 방문)
        visited[w] <- true;
    else
      if(스택이 비어 있지 않으면)
        v <- pop(stack);
      else
        break
   }
end DFS()
```
![Alt text](image.png)
- 1. 초기상태: 배열 visited를 False로 초기화하고 공백 스택을 생성
   - 정점 개수를 맞춰서 번호 제공 (0/1도 가능)
- 2. 정점 A를 시작으로 깊이 우선 탐색 시작
![Alt text](image-1.png)
- 3. 정점 A에 방문하지 않은 정점 B, C가 있으므로 A를 스택에 push하고, 인접정점 중 오름차순에 따라 B 선택
![Alt text](image-2.png)
- 4. 정점 B에 방문하지 않은 정점 D, E가 있으므로 B를 스택에 push하고, 인접정점 중 오름차순에 따라 D 선택
- 5. 정점 D에 방문하지 않은 정점 F가 있으므로 D를 스택에 push하고, 인접정점 F 선택
![Alt text](image-3.png)
- 6. 정점 F에 방문하지 않은 정점 E, G가 있으므로 F를 스택에 push하고, 인접정점 중 오름차순에 따라 E 선택
- 7. 정점 E에 방문하지 않은 정점 C가 있으므로 E를 스택에 push하고, 인접정점 C 선택
- 8. 정점 C에서 더이상 갈 곳이 없으므로, 마지막 정점으로 돌아가기 위해 스택을 pop하여 받은 정점 E에 대하여 방문하지 않은 인접정점이 있는지 확인
![Alt text](image-4.png)
- 9. 정점 F에 방문하지 않은 정점 G가 있으므로 F를 스택에 push하고, 인접정점 G 선택하여 탐색
- 10. 남은 정점이 있는지 스택 요소들을 pop하여 확인하기에 탐색이 끝나면 스택에 남는 것이 없게 됨
![Alt text](image-5.png)
- > 깊이 우선 탐색 경로: A - B - D - F - E - C - G